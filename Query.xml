<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Red Hat Enterprise Linux for x86-64) 2017.1 (Build 792U)" ts="2017-10-31 14:54:10">
<Class name="Query.IVFQuery">
<Super>%RegisteredObject</Super>
<TimeChanged>64456,54239.273266</TimeChanged>
<TimeCreated>64456,52250.339338</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// IVF同一天同一人同一套餐类型算一人

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// D ##class(%ResultSet).RunQuery("Query.IVFQuery","IVFCount","2017-5-1","2017-5-31")

]]></Content>
</UDLText>

<Query name="IVFCount">
<Type>%Query</Type>
<FormalSpec>sday:%String,eday:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Product:%String,Count:%String,Revenue:%String,test:%String"/>
</Query>

<Method name="IVFCountExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,sday:%String,eday:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
                k ^||TEMPIVF($j)
                s sday=$zdh(sday,3)
                s eday=$zdh(eday,3)
                f day=sday:1:eday  d
                .s pId=0 f  s pId=$o(^Data.PackageSaleI("QueryDate",day,pId)) q:pId=""  d
                ..s Hos=$li(^Data.PackageSaleD(pId),23)
                ..s pType=$li(^Data.PackageSaleD(pId),31)
                ..//q:pType'="孕育套餐"
                ..s pStype=$li(^Data.PackageSaleD(pId),30)
                ..q:(pStype'="IVF")&(pStype'="IUI")&(pStype'="FET")
                ..s patno=$li(^Data.PackageSaleD(pId),8)
                ..s refundflag=$li(^Data.PackageSaleD(pId),27)
                ..s cDay=$zd(day,3)
                ..s Mon=$p(cDay,"-",1,2)
                ..s num=$li(^Data.PackageSaleD(pId),63)
                ..i refundflag="N" s ^||TEMPIVF($j,day,Hos,patno,pStype)=1
                
                b
                set rs=##class(%DeepSee.ResultSet).%New()
               // d rs.%PrepareMDX("select [DateOfSale].[Actual].[YearSold].Members on 1 from [HOLEFOODS]")
                do rs.%PrepareMDX(mdxString)
                d rs.%Execute()
                
                for i=1:1:rs.%GetAxisSize(2) {
                                d rs.%GetOrdinalLabel(.label,2,i)
                                set ^||%ISC.ZRS(i)=$lb(label(1),rs.%GetOrdinalValue(1,i),rs.%GetOrdinalValue(3,i),rs.%GetOrdinalValue(2,i))
                }
                
                Set qHandle = $LB("")
                
                Quit $$$OK
]]></Implementation>
</Method>

<Method name="IVFCountClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>IVFCountExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
                kill ^||%ISC.ZRS
                Quit $$$OK
]]></Implementation>
</Method>

<Method name="IVFCountFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>IVFCountExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set index = $List(qHandle,1)
    Set index = $O(^||%ISC.ZRS(index))
    If index="" {
        Set Row = ""
        Set AtEnd = 1
    }
    Else {
        Set Row = ^||%ISC.ZRS(index)
    }
    Set qHandle = $LB(index)
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Query.PaadmCount">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64583,62211.197063</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PaadmCount").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.PaadmCountMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleCount").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PaadmCountMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
	s ^test("query")=Query 	
	//set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
	//set Query="HosDr_1,2,3,4,5,6@QueryDateStartMQueryDateEndM_201709;201710@UPDATEFLAG_No@TypeDesc_分娩套餐@SubTypeDesc_分娩套餐@RefundFlag_Normal"
     set Query="HosDr_1@QueryDateStartMQueryDateEndM_201609;201710@UPDATEFLAG_No@TypeDesc_@SubTypeDesc_产前套餐@RefundFlag_Normal"  
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateStartMQueryDateEndM"{     //QueryDateStartMQueryDateEndM_201609,201709
		     s Value=$p(data,"_",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDateStartMQueryDateEndM:"_Value	         
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p(data,"_",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }elseif Value [ ";" {
	           set value1=$p(Value,";",1)
	           set value2=$p(Value,";",2)
	           set Desc = "NONEMPTYCROSSJOIN(%OR("_Mdx_"["_value1_"]:&["_value2_"])"   
	             
	         }
             else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[MEASURES].[销售份数]) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(mdxString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
    
    /*   
    for i = 1:2:columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	    set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
    
    for i = 1:1:columns {//两行  第二行有一列
	    do rs.%GetOrdinalLabel(.label,1,i) //
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_"_label(1)
	  //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.PackageSaleCount">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64586,63418.020042</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PackageSaleCount").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.PackageSaleCountMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleCount").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PackageSaleCountMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
	s ^test("query")=Query 	
	//set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
	//set Query="HosDr_1,2,3,4,5,6@QueryDateStartMQueryDateEndM_201709;201710@UPDATEFLAG_No@TypeDesc_分娩套餐@SubTypeDesc_分娩套餐@RefundFlag_Normal"
     //set Query="HosDr_1@QueryDateStartMQueryDateEndM_201609;201710@UPDATEFLAG_No@TypeDesc_@SubTypeDesc_产前套餐@RefundFlag_Normal"  
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateStartMQueryDateEndM"{     //QueryDateStartMQueryDateEndM_201609,201709
		     s Value=$p(data,"_",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDateStartMQueryDateEndM:"_Value	         
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p(data,"_",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }elseif Value [ ";" {
	           set value1=$p(Value,";",1)
	           set value2=$p(Value,";",2)
	           set Desc = "NONEMPTYCROSSJOIN(%OR("_Mdx_"["_value1_"]:&["_value2_"])"   
	             
	         }
             else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[MEASURES].[销售份数]) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(mdxString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
    
    /*   
    for i = 1:2:columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	    set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
    
    for i = 1:1:columns {//两行  第二行有一列  有两列
	    do rs.%GetOrdinalLabel(.label,1,i) //
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_"_label(1)
	  //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.PackageSaleCounttest">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64586,62937.309657</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PackageSaleCounttest").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.PackageSaleCounttestMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleCounttest").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PackageSaleCounttestMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
		
	set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
	set Query="HosDr_1,2,3,4,5,6@QueryDateM_@UPDATEFLAG_No@TypeDesc_分娩套餐@SubTypeDesc_@RefundFlag_Normal"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateM"{
		     s Value=$p(data,"_",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p(data,"_",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[MEASURES].[销售份数]) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,{[MEASURES].[销售份数],[MEASURES].[销售金额]}) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE]"
    //b //1
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("") //Hos->TypeDesc
    
    /*   
    for i = 1:2:columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"->"_label(1)  
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(2)_"->"_label(1)	  
    }*/
    
    for i = 1:1:columns {
        do rs.%GetOrdinalLabel(.label,1,i)
        set ll = $listlength(^||%ISC.ZHeader($j))+1
        
        set $list(^||%ISC.ZHeader($j),ll) = label(1)_"->"_label(2) 
}
    
  /*  
    for i = 1:1:columns {//两行  第二行有一列
	    do rs.%GetOrdinalLabel(.label,1,i) //
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_"_label(1)
	  //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.PackageSaleMetaData">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64573,54817.64699</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PackageSaleMetaData").RSProc("","","1","No","201708")

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleMetaData").RSProc("","","")
 Methods you write
d ##Class("Query.PackageSaleMetaData").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PackageSaleMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
  
	W !,Query
	//set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
	set Query="HosDr_@QueryDateM_@QueryDateD_@QueryDateY_@UPDATEFLAG_No@TypeDesc_分娩套餐@SubTypeDesc_分娩套餐@RefundFlag_Normal"
      
                 
      s len=$l(Query,"@")
      
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateM"{
		     s Value=$p(data,"_",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p(data,"_",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      //s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[QueryDate].[H1].[QueryMonth].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
        //         _" "_FilterPara_last
      //w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(MDXString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(MDXString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    s newlen=lenmdx-1
    w !,"newlen^"_newlen  // 判断有几个度量
    
    s col=$p(MDXString,",",1)
    s collen=$l(col,"NONEMPTYCROSSJOIN")
    w !,"collen^"_collen   //判断列上有几行
    //s newcollen=collen-1 
        
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
       
    /*   
    for i = 1:2:columns {//列上三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数" //label(1)
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额" //label(1)
	        	  
    }
     */   
    /*
    for i = 1:2:columns {//列上两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	    set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */      
    /*
    for i = 1:1:columns {//列上两行  第二行有一列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)	   	  
    }
    */
    /*
    for i = 1:1:columns { //列上一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)	    	  
    }
    */
    
    
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
    }
   
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.PackageSaleMetaDataNew">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64573,40584.957291</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PackageSaleMetaDataNew").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.PackageSaleDescMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleMetaDataNew").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PackageSaleDescMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
	//SELECT CROSSJOIN([product].[P1].[product category].members,[product].[P1].[product name].members) ON 1,CROSSJOIN([dateofsale].[actual].[yearsold].members,{[Measures].[%Count],[Measures].[Amount Sold]}) ON 0 FROM [HOLEFOODS]
	// SELECT NON EMPTY NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[MEASURES].[销售金额]) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[TypeDesc].[H1].[TypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]
     
	
	/*set MDXString ="SELECT {[MEASURES].[销售份数],[MEASURES].[销售金额],[MEASURES].[退款份数],"
	_"[MEASURES].[退款金额],[MEASURES].[净销售份数],[MEASURES].[净销售金额]} ON 0,"
	_"NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	_"%FILTER NONEMPTYCROSSJOIN("_pFilterSpec
	_",NONEMPTYCROSSJOIN("_Date_",[UPDATEFLAG].[H1].[UPDATEFLAG].&["_UpdateFlag_"]))"*/
	
	//set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
	set Query="HosDr_''@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_''"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[MEASURES].[退款份数]) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(mdxString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
    
    /*   
    for i = 1:(lenmdx-1):columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"
	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	   set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
     
    
    for i = 1:1:columns {//两行  第二行有一列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_退款份数"
	   //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.PackageSaleNewCount">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64582,53633.957308</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PackageSaleNewCount").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.PackageSaleNewCountMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleCount").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PackageSaleNewCountMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
		
	//set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
    s ^testcz("query")=Query           
	  //set Query="HosDr_1,2,3,4,5,6@QueryDateStartMQueryDateEndM_201709;201710@UPDATEFLAG_No@TypeDesc_@SubTypeDesc_分娩套餐"
      
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateStartMQueryDateEndM"{     //QueryDateStartMQueryDateEndM_201609,201709
		     s Value=$p(data,"_",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDateStartMQueryDateEndM:"_Value	         
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p(data,"_",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }
	    		     
		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }elseif Value [ ";" {
	           set value1=$p(Value,";",1)
	           set value2=$p(Value,";",2)
	           set Desc = "NONEMPTYCROSSJOIN(%OR("_Mdx_"["_value1_"]:&["_value2_"])"   
	             
	         }
             else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[MEASURES].[退款份数]) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(mdxString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
    
    /*   
    for i = 1:(lenmdx-1):columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"
	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	   set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
     
    
    for i = 1:1:columns {//两行  第二行有一列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_"_label(1)
	   //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%String</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.PackageSaleRealCount">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64586,60293.248273</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.PackageSaleRealCount").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.PackageSaleRealCountMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleCount").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>PackageSaleRealCountMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
	s ^test("query")=Query 	
	//set MDXString="SELECT {[MEASURES].[销售份数],[MEASURES].[退款份数],[MEASURES].[净销售份数]} ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),400,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE]"
	s FilterPara=""
	//set Query="HosDr_1,2,3,4,5,6@QueryDateStartMQueryDateEndM_201709;201710@UPDATEFLAG_No@TypeDesc_分娩套餐@SubTypeDesc_分娩套餐@RefundFlag_Normal"
     set Query="HosDr_1@QueryDateStartMQueryDateEndM_201609;201710@UPDATEFLAG_No@TypeDesc_@SubTypeDesc_产前套餐@RefundFlag_Normal"  
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateStartMQueryDateEndM"{     //QueryDateStartMQueryDateEndM_201609,201709
		     s Value=$p(data,"_",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDateStartMQueryDateEndM:"_Value	         
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p(data,"_",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p(data,"_",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }elseif Value [ ";" {
	           set value1=$p(Value,";",1)
	           set value2=$p(Value,";",2)
	           set Desc = "NONEMPTYCROSSJOIN(%OR("_Mdx_"["_value1_"]:&["_value2_"])"   
	             
	         }
             else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY NONEMPTYCROSSJOIN([HosDr].[H1].[HosDr].Members,[MEASURES].[净销售份数]) ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(mdxString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
    
    /*   
    for i = 1:2:columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	    set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
    
    for i = 1:1:columns {//两行  第二行有一列
	    do rs.%GetOrdinalLabel(.label,1,i) //
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_"_label(1)
	  //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Class name="Query.QuestionnaireCiYMDX">
<Super>%RegisteredObject</Super>
<TimeChanged>64581,36799.038195</TimeChanged>
<TimeCreated>64455,56605.495728</TimeCreated>

<Method name="GetResultSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>QueryString:%String,*rs:%DeepSee.ResultSet</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
         // Create %DeepSee.ResultSet object
         set rs = ##class(%DeepSee.ResultSet).%New()
         quit:'$IsObject(rs) $$$ERROR($$$GeneralError,"Could not create %DeepSee.ResultSet object")
 
         // Prepare the MDX query
         set st = rs.%PrepareMDX(QueryString)
         quit:$$$ISERR(st) st
 
         // Execute the MDX query
         set st = rs.%Execute()
         quit st
]]></Implementation>
</Method>

<Method name="GetPivotInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>rs:%DeepSee.ResultSet,*Rows:%Integer,*Columns:%Integer,*HeaderRows:%Integer,*HeaderColumns:%Integer,*HeaderHandle:%String</FormalSpec>
<Implementation><![CDATA[
         set Rows = 0, Columns = 0, HeaderRows = 0, HeaderColumns = 0, HeaderHandle = ""
 
         try {
                           
         // Get the number of rows and columns
              set Columns = rs.%GetAxisSize(1)
              set Rows = rs.%GetAxisSize(2)
         // Get the number of header rows and header columns
         do rs.%GetAxisMembers(1,.HeaderHandle)
         set HeaderColumns = $order(^||DeepSee.AxisMember(HeaderHandle,1,Columns,999),-1)+1
         set HeaderRows = $order(^||DeepSee.AxisMembers(HeaderHandle, 2, Rows, 999), -1)+1
           for c=1:1:Columns {
                   set cellValues = rs.%GetOrdinalValue(c, r)
                   //.....
           }
   } catch {}
          quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// do ##class(%ResultSet).RunQuery("Query.QuestionnaireCiYMDX","Test")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// {call Query.QuestionnaireCiYMDX_Test('')}

]]></Content>
</UDLText>

<Query name="Test">
<Type>%Query</Type>
<FormalSpec>Query:%Text</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="QuestionnaireAnswerDesc,Count:%String"/>
</Query>

<Method name="TestExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Query:%Text]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	  k ^||tempamcare($j)
                
      ;s mdxString=##class(MDXCLS).GetMDXString(a,b,c)
      //w !,Query
      s FilterPara=""         
        
     //set Query="HosDr_@SubmitDate_@RecoFlag_@QuType_住院问卷@QUESTIONNAIREQUESTIONDESC_在您就诊期间，哪位工作人员的出色工作给您留下了深刻的印象：（门诊）,请您留下就诊印象或者意见建议（门诊）,在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）,
     //请您留下就诊印象或意见建议（住院）,
     //在您就诊期间，有哪位工作人员的出色工作给您留下深刻的印象,
     //请您留下就诊意见建议,
     //请您留下意见建议"
     
     
      // HosDr_亚运村分院@QueryDateStartMQueryDateEndM_201609,201710@QuType_住院问卷@RecoFlag_0@QUESTIONNAIREQUESTIONDESC_在您就诊期间，哪位工作人员的出色工作给您留下了深刻的印象：（门诊）,"_$c(10)_"请您留下就诊印象或者意见建议（门诊）,"_$c(10)_"在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）,"_$c(10)_"请您留下就诊印象或意见建议（住院）,"_$c(10)_"在您就诊期间，有哪位工作人员的出色工作给您留下深刻的印象,"_$c(10)_"请您留下就诊意见建议,"_$c(10)_"请您留下意见建议
      
      //set Query="HosDr_亚运村分院,丽都分院,万柳分院,杭州分院,深圳分院,天津分院,宜和门诊@QueryDateStartMQueryDateEndM_201608;201710@QuType_门诊问卷@RecoFlag_0@QUESTIONNAIREQUESTIONDESC_在您就诊期间，哪位工作人员的出色工作给您留下了深刻的印象：（门诊）,请您留下就诊印象或者意见建议（门诊）,在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）,请您留下就诊印象或意见建议（住院）,在您就诊期间，有哪位工作人员的出色工作给您留下深刻的印象,请您留下就诊意见建议,请您留下意见建议"     
              // HosDr_丽都分院@QueryDateEndM_201709@QuType_门诊问卷@RecoFlag_0@QUESTIONNAIREQUESTIONDESC_在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）,请您留下就诊印象或意见建议（住院）
     
      //set Query="HosDr_亚运村分院,丽都分院@QueryDateStartMQueryDateEndM_201609;201710@QuType_住院问卷@RecoFlag_0@QUESTIONNAIREQUESTIONDESC_在您就诊期间，哪位工作人员的出色工作给您留下了深刻的印象：（门诊）,请您留下就诊印象或者意见建议（门诊）,在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）,请您留下就诊印象或意见建议（住院）,在您就诊期间，有哪位工作人员的出色工作给您留下深刻的印象,请您留下就诊意见建议,请您留下意见建议"        
      s ^test("query")=Query 
      s len=$l(Query,"@")
      w !,"len_"_len
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<=len)&(Data1'=""){
	     s last=last_")" 
	    }
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" { 
		     s Value=$p(data,"_",2)
		     s Mdx="[HPDesc].[H1].[HPDesc].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDateStartMQueryDateEndM"{     //QueryDateStartMQueryDateEndM_201609,201709
		     s Value=$p(data,"_",2)
		     s Mdx="[SubmitDate].[H1].[SubmitM].&"
		     w !,"QueryDateStartMQueryDateEndM:"_Value	         
	    }
	    elseif  Data="RecoFlag"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[RecoFlag].[H1].[RecoFlag].&"
		}
		elseif  Data="QuType"{
		     s Value=$p(data,"_",2)
		     s Mdx="[QuType].[H1].[QuType].&"
	    }
	    elseif Data="QUESTIONNAIREQUESTIONDESC"{
		     s Value=$p(data,"_",2)
		     s Mdx="[QuestionnaireQuestionDesc].[H1].[QuestionnaireQuestionDesc].&"
		}
		
		//%FILTER NONEMPTYCROSSJOIN(%OR({[HPDESC].[H1].[HPDESC].&[丽都分院],[HPDESC].[H1].[HPDESC].&[亚运村分院]})
		//,NONEMPTYCROSSJOIN(%OR([SUBMITDATE].[H1].[SUBMITM].&[201601]:&[201710])
		//,NONEMPTYCROSSJOIN([QUTYPE].[H1].[QUTYPE].&[门诊问卷],[RECOFLAG].[H1].[RECOFLAG].&[1])))

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到一个维度的多个数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
             
             }elseif Value [ ";" {
	           set value1=$p(Value,";",1)
	           set value2=$p(Value,";",2)
	           set Desc = "NONEMPTYCROSSJOIN(%OR("_Mdx_"["_value1_"]:&["_value2_"])"   
	             
	         }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
      }
      
      
        w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY [DevideValue].[H1].[DevideValue].Members ON 1 FROM [CUBE.QUESTIONDETAILS] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
      
       set rs=##class(%DeepSee.ResultSet).%New()
                   
                d rs.%PrepareMDX(mdxString)
                d rs.%Execute()
                ;b	//1
                s j=1
                for i=1:1:rs.%GetAxisSize(2) {
                                d rs.%GetOrdinalLabel(.label,2,i) 
                                //i label(1)["王虹@主任@ 医术@ 高超@"  b //                             
                                s count=$l(label(1),"@")
                                f h=1:1:count-1  d
                                .s str=$tr($p(label(1),"@",h)," ")
                                .i str="" s str="空"
                                
                                .s ^||tempamcare($j,str)=$g(^||tempamcare($j,str))+rs.%GetOrdinalValue(1,i)
                                .//set ^||%ISC.ZRS(j)=$lb(str,rs.%GetOrdinalValue(1,i),rs.%GetOrdinalValue(2,i))   
                                .//s j=j+1 
                                .;b	//1                           
                                
                }
                s dim=0 f  s dim=$o(^||tempamcare($j,dim)) q:dim=""  d
                .s ^||%ISC.ZRS(j)=$lb(dim,$g(^||tempamcare($j,dim)))
                .s j=j+1
                Set qHandle = $LB("")
            
                 
                Quit $$$OK
]]></Implementation>
</Method>

<Method name="TestClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>TestExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[                Quit $$$OK
]]></Implementation>
</Method>

<Method name="TestFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>TestExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set index = $List(qHandle,1)
    Set index = $O(^||%ISC.ZRS(index))
    If index="" {
        Set Row = ""
        Set AtEnd = 1
    }
    Else {
        Set Row = ^||%ISC.ZRS(index)
    }
    Set qHandle = $LB(index)
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Query.QuestionnaireCiYunMDX">
<Super>%RegisteredObject</Super>
<TimeChanged>64573,61107.015274</TimeChanged>
<TimeCreated>64455,56605.495728</TimeCreated>

<Method name="GetResultSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>QueryString:%String,*rs:%DeepSee.ResultSet</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
         // Create %DeepSee.ResultSet object
         set rs = ##class(%DeepSee.ResultSet).%New()
         quit:'$IsObject(rs) $$$ERROR($$$GeneralError,"Could not create %DeepSee.ResultSet object")
 
         // Prepare the MDX query
         set st = rs.%PrepareMDX(QueryString)
         quit:$$$ISERR(st) st
 
         // Execute the MDX query
         set st = rs.%Execute()
         quit st
]]></Implementation>
</Method>

<Method name="GetPivotInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>rs:%DeepSee.ResultSet,*Rows:%Integer,*Columns:%Integer,*HeaderRows:%Integer,*HeaderColumns:%Integer,*HeaderHandle:%String</FormalSpec>
<Implementation><![CDATA[
         set Rows = 0, Columns = 0, HeaderRows = 0, HeaderColumns = 0, HeaderHandle = ""
 
         try {
                           
         // Get the number of rows and columns
              set Columns = rs.%GetAxisSize(1)
              set Rows = rs.%GetAxisSize(2)
         // Get the number of header rows and header columns
         do rs.%GetAxisMembers(1,.HeaderHandle)
         set HeaderColumns = $order(^||DeepSee.AxisMember(HeaderHandle,1,Columns,999),-1)+1
         set HeaderRows = $order(^||DeepSee.AxisMembers(HeaderHandle, 2, Rows, 999), -1)+1
           for c=1:1:Columns {
                   set cellValues = rs.%GetOrdinalValue(c, r)
                   //.....
           }
   } catch {}
          quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// do ##class(%ResultSet).RunQuery("Query.QuestionnaireCiYunMDX","Test")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// {call Query.QuestionnaireCiYunMDX()} 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// {call Query.QuestionnaireCiYunMDX_Test("")}

]]></Content>
</UDLText>

<Query name="Test">
<Type>%Query</Type>
<FormalSpec>Query:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="QuestionnaireAnswerDesc,Count:%String"/>
</Query>

<Method name="TestExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Query:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	  k ^||tempamcare($j)
      
      //w !,Query
      //set Query1='"'_Query_
      ;s mdxString=##class(MDXCLS).GetMDXString(a,b,c)
      s FilterPara=""         
      set Query="HosDr_@SubmitDate_@RecoFlag_@QuType_住院问卷@QUESTIONNAIREQUESTIONDESC_在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）,请您留下就诊印象或意见建议（住院）"
                
      s len=$l(Query,"@")
      w !,"len_"_len
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<=len)&(Data1'=""){
	     s last=last_")" 
	    }
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" { 
		     s Value=$p(data,"_",2)
		     s Mdx="[HPDesc].[H1].[HPDesc].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="SubmitDate"{
		     s Value=$p(data,"_",2)
		     s Mdx="[SubmitDate].[H1].[SubmitM].&"
		     w !,"SubmitDate:"_Value
	    }
	    elseif  Data="RecoFlag"{	     
		     s Value=$p(data,"_",2)
		     s Mdx="[RecoFlag].[H1].[RecoFlag].&"
		}
		elseif  Data="QuType"{
		     s Value=$p(data,"_",2)
		     s Mdx="[QuType].[H1].[QuType].&"
	    }
	    elseif Data="QUESTIONNAIREQUESTIONDESC"{
		     s Value=$p(data,"_",2)
		     s Mdx="[QuestionnaireQuestionDesc].[H1].[QuestionnaireQuestionDesc].&"
		}

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到一个维度的多个数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
      }
      
      
        w !,"d》"_FilterPara
      s mdxString="SELECT NON EMPTY [DevideValue].[H1].[DevideValue].Members ON 1 FROM [CUBE.QUESTIONDETAILS] %FILTER"
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
      
       set rs=##class(%DeepSee.ResultSet).%New()
                   
           //     d rs.%PrepareMDX(mdxString)
                d rs.%Execute()
                ;b	//1
                s j=1
                for i=1:1:rs.%GetAxisSize(2) {
                                d rs.%GetOrdinalLabel(.label,2,i) 
                                //i label(1)["王虹@主任@ 医术@ 高超@"  b //                             
                                s count=$l(label(1),"@")
                                f h=1:1:count-1  d
                                .s str=$tr($p(label(1),"@",h)," ")
                                .i str="" s str="空"
                                
                                .s ^||tempamcare($j,str)=$g(^||tempamcare($j,str))+rs.%GetOrdinalValue(1,i)
                                .//set ^||%ISC.ZRS(j)=$lb(str,rs.%GetOrdinalValue(1,i),rs.%GetOrdinalValue(2,i))   
                                .//s j=j+1 
                                .;b	//1                           
                                
                }
                s dim=0 f  s dim=$o(^||tempamcare($j,dim)) q:dim=""  d
                .s ^||%ISC.ZRS(j)=$lb(dim,$g(^||tempamcare($j,dim)))
                .s j=j+1
                Set qHandle = $LB("")
                
                Quit $$$OK
]]></Implementation>
</Method>

<Method name="TestClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>TestExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[                Quit $$$OK
]]></Implementation>
</Method>

<Method name="TestFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>TestExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set index = $List(qHandle,1)
    Set index = $O(^||%ISC.ZRS(index))
    If index="" {
        Set Row = ""
        Set AtEnd = 1
    }
    Else {
        Set Row = ^||%ISC.ZRS(index)
    }
    Set qHandle = $LB(index)
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Query.QuestionnaireMDX">
<Super>%RegisteredObject</Super>
<TimeChanged>64474,62650.475214</TimeChanged>
<TimeCreated>64468,58387.568842</TimeCreated>

<Method name="GetResultSet">
<ClassMethod>1</ClassMethod>
<FormalSpec>QueryString:%String,*rs:%DeepSee.ResultSet</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
         // Create %DeepSee.ResultSet object
         set rs = ##class(%DeepSee.ResultSet).%New()
         quit:'$IsObject(rs) $$$ERROR($$$GeneralError,"Could not create %DeepSee.ResultSet object")
 
         // Prepare the MDX query
         set st = rs.%PrepareMDX(QueryString)
         quit:$$$ISERR(st) st
 
         // Execute the MDX query
         set st = rs.%Execute()
         quit st
]]></Implementation>
</Method>

<Method name="GetPivotInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>rs:%DeepSee.ResultSet,*Rows:%Integer,*Columns:%Integer,*HeaderRows:%Integer,*HeaderColumns:%Integer,*HeaderHandle:%String</FormalSpec>
<Implementation><![CDATA[
         set Rows = 0, Columns = 0, HeaderRows = 0, HeaderColumns = 0, HeaderHandle = ""
 
         try {
                           
         // Get the number of rows and columns
              set Columns = rs.%GetAxisSize(1)
              set Rows = rs.%GetAxisSize(2)
         // Get the number of header rows and header columns
         do rs.%GetAxisMembers(1,.HeaderHandle)
         set HeaderColumns = $order(^||DeepSee.AxisMember(HeaderHandle,1,Columns,999),-1)+1
         set HeaderRows = $order(^||DeepSee.AxisMembers(HeaderHandle, 2, Rows, 999), -1)+1
           for c=1:1:Columns {
                   set cellValues = rs.%GetOrdinalValue(c, r)
                   //.....
           }
   } catch {}
          quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// do ##class(%ResultSet).RunQuery("Query.QuestionnaireMDX","Question","SELECT NON EMPTY [Value].[H1].[Value].Members ON 1 FROM [CUBE.QUESTIONDETAILS] %FILTER %OR({[QUESTIONNAIREQUESTIONDESC].[H1].[QUESTIONNAIREQUESTIONDESC].&[在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）],[QUESTIONNAIREQUESTIONDESC].[H1].[QUESTIONNAIREQUESTIONDESC].&[请您留下就诊印象或意见建议（住院）]})")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// HosDr:%String,TypeDesc:%String,Count:%String,price:%String

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// CALL Query.QuestionnaireMDX_Question('SELECT NON EMPTY [Value].[H1].[Value].Members ON 1 FROM [CUBE.QUESTIONDETAILS] %FILTER %OR({[QUESTIONNAIREQUESTIONDESC].[H1].[QUESTIONNAIREQUESTIONDESC].&[在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）],[QUESTIONNAIREQUESTIONDESC].[H1].[QUESTIONNAIREQUESTIONDESC].&[请您留下就诊印象或意见建议（住院）]})')

]]></Content>
</UDLText>

<Query name="Question">
<Type>%Query</Type>
<FormalSpec>mdx:%Text,HosDr:%String,StartDate:%String,EndDate:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="QuestionnaireAnswerDesc,Count:%String"/>
</Query>

<Method name="QuestionExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,mdx:%Text]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	           if HosDr = "" { 
                    set Hospital = "[HPDesc].[H1].[HPDesc].[No Member]"     
	           }elseif HosDr [ "," { 
                    set HosDr1 = $listfromstring(HosDr,",")
                    set Hospital = "%OR({[HPDesc].[H1].[HPDesc].["
                    for i= 1:1:$ll(HosDr1) {
                        set HosDr = $list(HosDr1,i)
                        if (i'= $ll(HosDr1)) {                 
                            set Hospital = Hospital_HosDr_"],[HPDesc].[H1].[HPDesc].["
                            } else {
                                set Hospital = Hospital_HosDr_"]})"
                            }
                    }
               }else{
                    set Hospital = "[HPDesc].[H1].[HPDesc].["_HosDr_"]"            
                  
               }               
              
	           k ^||tempamcare($j)
               set rs=##class(%DeepSee.ResultSet).%New()
                               
                s mdxString=mdx_Hospital_"}),%OR({[SUBMITDATE].[H1].[SUBMITM].&["_StartDate_
                "],[SUBMITDATE].[H1].[SUBMITM].&["_EndDate_"]})))"
                
                //s mdxString="SELECT NON EMPTY [DevideValue].[H1].[DevideValue].Members ON 1 FROM [CUBE.QUESTIONDETAILS]%FILTER NONEMPTYCROSSJOIN(%OR({[QUESTIONNAIREQUESTIONDESC].[H1].[QUESTIONNAIREQUESTIONDESC].&[在您住院期间有哪位工作人员的出色工作给您留下深刻印象（住院）],[QUESTIONNAIREQUESTIONDESC].[H1].[QUESTIONNAIREQUESTIONDESC].&[请您留下就诊印象或意见建议（住院）]}),NONEMPTYCROSSJOIN(%OR({[HPDesc].[H1].[HPDesc].[亚运村分院]}),%OR({[SUBMITDATE].[H1].[SUBMITM].&[201705],[SUBMITDATE].[H1].[SUBMITM].&[201707]})))"
                
                d rs.%PrepareMDX(mdxString)
                d rs.%Execute()
                
                s j=1
                
                for i=1:1:rs.%GetAxisSize(2) {	                           
                                d rs.%GetOrdinalLabel(.label,2,i) 
                                //i label(1)["王虹@主任@ 医术@ 高超@"  b //                             
                                s count=$l(label(1),"@")
                                f h=1:1:count-1  d
                                .s str=$tr($p(label(1),"@",h)," ")
                                .i str="" s str="空"                              
                                .s ^||tempamcare($j,str)=$g(^||tempamcare($j,str))+rs.%GetOrdinalValue(1,i)
                                .//set ^||%ISC.ZRS(j)=$lb(str,rs.%GetOrdinalValue(1,i),rs.%GetOrdinalValue(2,i))   
                                .//s j=j+1 
                                .;b	//1                           
                }
                s dim=0 f  s dim=$o(^||tempamcare($j,dim)) q:dim=""  d
                .s ^||%ISC.ZRS(j)=$lb(dim,$g(^||tempamcare($j,dim)))
                .s j=j+1
                Set qHandle = $LB("")
                
                Quit $$$OK
]]></Implementation>
</Method>

<Method name="QuestionClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>QuestionExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[                Quit $$$OK
]]></Implementation>
</Method>

<Method name="QuestionFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>QuestionExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set index = $List(qHandle,1)
    Set index = $O(^||%ISC.ZRS(index))
    If index="" {
        Set Row = ""
        Set AtEnd = 1
    }
    Else {
        Set Row = ^||%ISC.ZRS(index)
    }
    Set qHandle = $LB(index)
    Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Query.QuestionnaireMZcount">
<Description>
This class is an example of subclassing %SQL.CustomResultSet. Custom result sets are similar
to queries with TYPE = %Library.Query. Subclassing %SQL.CustomResultSet has a few advantages
over custom queries. Result sets are somewhat more efficient when interacting with the server.
The metadata for a result set is constructed from the class definition so there is never a need for
ROWSPEC. Also, result sets provide a more OO interface.

The result set created by this class contains rows (the number of rows specified at instantiation)
of randomly generated data.

When subclassing %SQL.CustomResultSet, there are a few steps that you must follow in order to produce
a working result set.

	1.	Define properties that correspond to each column in the result row.
	2.	Define private properties that you need to maintain the current state of the
		result set.
	3.	Override and implement %OpenCursor. In this method you will initialize the result
		iterator and prepare the data for return. Report any errors encountered during execution
			by setting %SQLCODE and %Message.
	4.	Override and implement %Next. In this method you will retrieve the next row. If the end
		of the result set is reached then return 0. Otherwise, set the row properties to the
		appropriate value and return 1.
	5.	Override and implement %CloseCursor. This is only necessary if you need to perform some
		clean up.

	If you wish to instantiate your custom result set class and return it to a caller then you must
implement an SQL routine (aka, "stored procedure"). This class includes an SQL routine 'CustomResult'.

Instances of %SQL.IResultSet are not meant to be "reused" meaning that a result set class
expects to be instantiated, the rows iterated over, and then destructed.</Description>
<IncludeCode>%occErrors</IncludeCode>
<Super>%SQL.CustomResultSet</Super>
<TimeChanged>64587,53267.884211</TimeChanged>
<TimeCreated>60710,28678.859</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// By defining one MumltiDimensional Property you can support N columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// In the Next code just subscript the Data property with an integer value, 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// one for each column in the report

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// s ..Data(1)="Col 1",..Data(2)="Col 2"....

]]></Content>
</UDLText>

<Property name="Data">
<Description>
 Property Defs</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Then you can define some custom result set state properties. 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// These properties are for your own use to maintain the result set state during the data retrieval cycle (%Next()). 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Old queries used qhandle to maintain the cursor status. Here we just use private properties.

]]></Content>
</UDLText>

<Property name="ZCursorName">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ZCursorId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<UDLText name="T">
<Content><![CDATA[
// This is the Class method that will expose this code as a ResultSet.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// It can be called as a Method from terminal or as a Stored Procedure from xDBC

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  d ##Class("Query.QuestionnaireMZcount").RSProc("1","0","")

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  CALL Query.QuestionnaireMZcountMDX('1','0','')    

]]></Content>
</UDLText>

<Method name="RSProc">
<Description>
d ##Class("Query.PackageSaleCount").RSProc("1","0","")
 Methods you write</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,display:%Integer=0,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<SqlName>QuestionnaireMZcountMDX</SqlName>
<SqlProc>1</SqlProc>
<ReturnResultsets>1</ReturnResultsets>
<Implementation><![CDATA[
 	#dim %sqlcontext As %Library.ProcedureContext
 	
 	//b //1
 	try {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	#; The first argument passed to %New() is the SELECTMODE. It defaults to the current setting for
	#; the process ($system.SQL.GetSelectMode()).
	
	    
		set tResult = ..%New(,RowCount,Query)
		do %sqlcontext.AddResultSet(tResult)
		
 	} catch tException {
	 	if '$Isobject($Get(%sqlcontext)) { 
	 		set %sqlcontext = ##class(%Library.ProcedureContext).%New() 
	 	}
	 	
		if tException.%IsA("%Exception.SQL") { 
			set ..%SQLCODE = tException.Code
			set ..%Message = tException.Data 
		} elseif tException.%IsA("%Exception.StatusException") {
			 if (tException.Code = $$$SQLError) || (tException.Code = $$$SQLCode) {
				  set ..%SQLCODE = $Listget(tException.Data,1), ..%Message = $Listget(tException.Data,2) 
			} 
		} else { 
			set %sqlcontext.%SQLCODE = -400
			set %sqlcontext.%Message = "Exception caught during Sample.RSProcMDnew procedure execution: " _ tException.Name_":"_tException.Data 
		}
 	}
	 	
 	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// This is the simple method that is called to generate the data for this example.

]]></Content>
</UDLText>

<Method name="MyCode">
<ClassMethod>1</ClassMethod>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	
    // set MDX String here, also you can pass the query parameter via stored procedure parameter (e.g. RowCount) and 
	// concate your own MDX string here	
	s ^test("query")=Query 	
	//set MDXString=""
	s FilterPara=""
	
     //set Query="HosDr_1@SubmitDate_201609;201710@QuType_门诊问卷"  
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p(data,"_",2)	    
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p(data,"_",2)
		     s Mdx="[HPDesc].[H1].[HPDesc].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="SubmitDate"{     
		     s Value=$p(data,"_",2)
		     s Mdx="[SubmitDate].[H1].[SubmitM].&"
		     w !,"QueryDateStartMQueryDateEndM:"_Value	         
	    } 
	    elseif  Data="QuType"{     
		     s Value=$p(data,"_",2)
		     s Mdx="[QuType].[H1].[QuType].&"
		     w !,"[QuType]:"_Value	         
	    }
	    

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }elseif Value [ ";" {
	           set value1=$p(Value,";",1)
	           set value2=$p(Value,";",2)
	           set Desc = "NONEMPTYCROSSJOIN(%OR("_Mdx_"["_value1_"]:&["_value2_"])"   
	             
	         }
             else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc = Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d》"_FilterPara
      s mdxString=""
                 _" "_FilterPara_last
      w !,"mdxString="_mdxString
		
	set rs=##class(%DeepSee.ResultSet).%New()
    
    //set MDXString="SELECT NON EMPTY NONEMPTYCROSSJOIN(NONEMPTYCROSSJOIN([QueryDate].[H1].[QueryYear].Members,[HosDr].[H1].[HosDr].Members),{[MEASURES].[净销售份数],[MEASURES].[净销售金额]}) ON 0,NON EMPTY HEAD(NONEMPTYCROSSJOIN([TypeDesc].[H1].[TypeDesc].Members,[SubTypeDesc].[H1].[SubTypeDesc].Members),2000,SAMPLE) ON 1 FROM [CUBE.PACKAGESALE] %FILTER %OR({[HOSDR].[H1].[HOSDR].&[2],[HOSDR].[H1].[HOSDR].&[1]})"
    set status= rs.%PrepareMDX(mdxString)
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }
    //b //5
    set status = rs.%Execute()
    
    if 'status {
	    set %sqlcontext.%SQLCODE = -400
	    set %sqlcontext.%Message = "Exception caught during PrepareMDX: "_$System.Status.GetErrorCodes(status)_": "_$System.Status.GetErrorText(status)
	    do $System.OBJ.DisplayError(status)
	    quit status
    }

    s lenmdx=$l(mdxString,"MEASURES")
    w !,"lenmdx^"_lenmdx
    
    set columns = rs.%GetAxisSize(1)
    set rows = rs.%GetAxisSize(2)
    
    w !,"rows^"_rows
    w !,"columns^"_columns
    
    set ^||%ISC.ZHeader($j) = $lb("Hos->TypeDesc")
    
    /*   
    for i = 1:2:columns {//三行 第三行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(3)_"_"_label(2)_"_"_"净销售份数"
	    set $list(^||%ISC.ZHeader($j),ll+1) = label(3)_"_"_label(2)_"_"_"净销售金额"	   
	 // set $list(^||%ISC.ZHeader($j),ll+2) = label(3)_"_"_label(2)_"_"_label(1)    	  
    }
    
    */
    /*
    for i = 1:2:columns {//两行  第二行有两列
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = "销售金额_"_label(2)
	    set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    */
    
    
    for i = 1:1:columns {//两行  第二行有一列  有两列
	    do rs.%GetOrdinalLabel(.label,1,i) //
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    
	    set $list(^||%ISC.ZHeader($j),ll) = label(2)_"_"_label(1)
	  //set $list(^||%ISC.ZHeader($j),ll+1) = "Revenue_"_label(2)	  
    }
    
    
    //b //7
    /*
    for i = 1:1:columns { //一行
	    do rs.%GetOrdinalLabel(.label,1,i)
	    set ll = $listlength(^||%ISC.ZHeader($j))+1
	    set $list(^||%ISC.ZHeader($j),ll) = label(1)
	    //set $list(^||%ISC.ZHeader($j),ll+1) = label(2)	  
    }
    */
    // set ^ZTest(0) = ^||%ISC.ZHeader($j)
    //b //8
    for r=1:1:rows {//多行        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    /*
     for r=1:1:rows {//多列
        b //9
	    do rs.%GetOrdinalLabel(.label,2,r)	    
	    set ^||%ISC.ZRS(r)=$lb(label(2)_"->"_label(1))
	    for c=1:1:columns {
	    	set $list(^||%ISC.ZRS(r),c+1)=rs.%GetOrdinalValue(c,r)
	    }
	   // set ^ZTest(r)=^||%ISC.ZRS(r)
    }
    */
    quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  %OpenCursor(), %Next(), %CloseCursor(), and %GetSerializedMetaData() 

]]></Content>
</UDLText>

<Method name="%OpenCursor">
<Description>
Methods you override
%OpenCursor() is used to initialize the cursor for iterating over the result set.
Define formal arguments if needed. They will be automatically managed. If you need
to access these argument values during the %OpenCursor/%Next/%CloseCursor cycle
then simply define private properties as needed.</Description>
<FormalSpec>RowCount:%Integer=1,Query:%Text</FormalSpec>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
	; simplest case where I just call a method that builds a global
	; sounds like you might be doing this or calling COS code from here
	
	d ..MyCode(RowCount,Query)
	set ..ZCursorName = ""
	set ..ZCursorId = 0
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the
result set.</Description>
<FormalSpec><![CDATA[&sc:%Library.Status]]></FormalSpec>
<PlaceAfter>%Execute</PlaceAfter>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
		#; This sample uses two private properties to maintain the iterator.
		#; The first check is to see if we are at end, if so we quit with 0 (zero).
	
	set ..ZCursorId = $o(^||%ISC.ZRS(..ZCursorId))
		
		#; no more rows in the result set, quit 0
	if ..ZCursorId = "" { 
		set ..ZCursorName = "" 
		QUIT 0 
	} 
	
	set aList = ^||%ISC.ZRS(..ZCursorId)
	
		#; Set the row properties from the underlying data.
	for i=1:1:$ll(aList) {
		set ..Data(i) = $list(aList,i)
	}
		#; Increment ROWCOUNT- this is done automatically for SQL based result sets (that is, subclasses of %ResultSet.SQL)
		#; but custom result sets must do this manually. You can also set SQLCODE if you wish.
	set ..%RowCount = ..%RowCount + 1
		#; found a valid row quit 1
	QUIT 1
]]></Implementation>
</Method>

<Method name="%CloseCursor">
<Description>
Clean up on destruct</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill ^||%ISC.ZRS
	kill ^||%ISC.ZHeader
	set ..ZCursorName = ""
	set ..ZCursorId = ""
	Quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  You must write the code for this method.  

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Right now the method is hard coded to return Metadata for 3 columns

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  for this to be truely dynamic this code should build the Metadata based on runtime info.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  This method is called after %OpenCussor, so you can base this code on things defiend there

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  The Metadata info could be a parameter that is passed in

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  Maybe the code called in %OpenCursor, in this case MyCode() would generate info about the Metadata

]]></Content>
</UDLText>

<Method name="%GetSerializedMetadata">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pMetadata:%CacheString=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	
	The $LIST() that is returned by this method contains all the field Metadata for the given query
	If this is really a Dynamic Custom query then you need to generate the $LIST based on data passed in
	
	First $LB() is the Number of Columns
	
	Metadata for each Column is:
				#;		 1) Name
				#;		 2) ODBC Type
		 		#;		 3) Precision
				#;		 4) Scale
				#;		 5) Nullable
				#;		 6) Column Label (same as Name)
				#;		 7) Column Table Name
				#;		 8) Column Schema Name
				#;		 9) Column Qualifier Name - NULL
				#;		10) $ASCII String ($c(1)/$c(0)) position:
				#;			 1)  isAutoIncrement
				#;			 2)  isCaseSensitive
				#;			 3)  isCurrency
				#;			 4)  IsReadOnly
				#;			 5)  IsRowVersion
				#;			 6)  IsUnique
				#;			 7)  IsAliased
				#;			 8)  IsExpression
				#;			 9) IsHidden
				#;			10) IsIdentity
				#;			11) IsKeyColumn
	
	
	details for ODBC Type
				
	"INTEGER" s odbctype=4
	"SMALLINT" s odbctype=5
	"TINYINT" s odbctype=-6
	"BIGINT" s odbctype=-5
	"DOUBLE" s odbctype=8
	"NUMERIC" s odbctype=2
	"BIT" s odbctype=-7
	"DATE" s odbctype=9
	"TIME" s odbctype=10
	"TIMESTAMP" s odbctype=11
	"RESULTSET" s odbctype=-51 
	"LONGVARBINARY" s odbctype=-4
	"LONGVARCHAR" s odbctype=-1 
	"VARBINARY" s odbctype=-3 
	"VARCHAR",odbctype=12 

				
	*/	
   
	s AsciiFlag=$c(0,0,0,0,0,0,0,0,0,0,0)
		
	set columns = $listlength($g(^||%ISC.ZHeader($j)))
	set pMetadata = $lb(columns)
	for k = 1:1:columns {
		set colHeader = $list($g(^||%ISC.ZHeader($j)),k)
		set pMetadata = pMetadata_$lb(colHeader,12,50,0,1,colHeader,"CustomMetaDataNew","Query","",AsciiFlag)
	}
	set ^ZTest("metadata")=pMetadata
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  These last three methods override the %Get, %GetData, %SendODBC methods from %Results.Custom

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you work with a MultiDimensional Array called Data with column numbers are subscripts then these methods do not need to change.

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
//  If you change the structure of how the Row Data is stored then these methods need to change.

]]></Content>
</UDLText>

<Method name="%Get">
<Description>
Methods you should be able to Reuse</Description>
<FormalSpec>colname:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column name find the Column number by reading the Metadata and return the Data(col) value
	try {
		k Names
		s mdata=..%GetSerializedMetaData()
		s Count=$LG(mdata,1)-1
		f i=0:1:Count s Names($LG(mdata,(i*9+2)))=i
		s col=Names(colname)
		set returnVal = ..Data(col)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_colname_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%GetData">
<FormalSpec>colnbr:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		#; for a given column number return the Data(colnbr) value
	 try {
		set returnVal = ..Data(colnbr)
	}
	catch {
		Do $ZU(96,3,149,1,"","property "_"Column #: "_colnbr_" of class "_..%ClassName(3))
	}
	quit returnVal
]]></Implementation>
</Method>

<Method name="%SendODBC">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	#; this method is called by the xDBC server and writes out the data.
	s Full=0
	s MaxCol=$LG(..%Metadata)
	i ..ZCursorId=0 d ..%Next()
%t1	Set Col=..%NextColumn 
	f Column=Col:1:MaxCol
	{
		#; $zobjexport puts data on the wire
		#; returns 1 when the packet is full and sent to the client
		If $zobjexport(..Data(Column),7) {Set ..%NextColumn = Column,Full=1 QUIT} 
	}
	If Full=1 QUIT 0
	If (..%Next(.sc)) s ..%NextColumn=1 Goto %t1
	Quit 100
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//d ##class(Query.PackageSaleMetaDataNew).Test()
	/*s str="HosDr_'1,2'@QueryDate_''@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'@"	
	s len=$l(str,"@")
	f i=1:1:len d
	.s data=$p(str,"@",i)
	.i data["HosDr" w $p(data,"_",2)_" "
  
	q 1*/
	s FilterPara=""
	set Query="HosDr_'1'@QueryDate_'201708'@UPDATEFLAG_'No'@TypeDesc_'分娩套餐'@SubTypeDesc_'分娩套餐'@RefundFlag_'Normal'"
                 
      s len=$l(Query,"@")
      s Value=""
      s last=""
      for i=1:1:len{	  
	    s data=$p(Query,"@",i)
	    w !,data_i
	    s Data=$p(data,"_",1)
	    w !,Data
	    s Data1=$p($p(data,"_",2),"'",2)
	    i (i<len)&(Data1'="") s last=last_")" 
	    w !,"Data1"_Data1
	    
	    i Data="HosDr" {
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[HOSDR].[H1].[HOSDR].&"
		     w !,"HosDr:"_Value
	    }
	    elseif  Data="QueryDate"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[QueryDate].[H1].[QueryMonth].&"
		     w !,"QueryDate:"_Value
	    }
	    elseif  Data="UPDATEFLAG"{	     
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[UPDATEFLAG].[H1].[UPDATEFLAG].&"
		}
		elseif  Data="SubTypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[SubTypeDesc].[H1].[SubTypeDesc].&"
	    }
	    elseif  Data="TypeDesc"{
		     s Value=$p($p(data,"_",2),"'",2)
		     s Mdx="[TypeDesc].[H1].[TypeDesc].&"	    
	    }
	    elseif Data="RefundFlag"{ 
	         s Value=$p($p(data,"_",2),"'",2)
	         s Mdx="[RefundFlag].[H1].[RefundFlag].&"
	    }

		     if Value = "" { 
                set Desc = "" 
		     }elseif Value [ "," { //可以查到多个院区的数据                
                   set areaList = $listfromstring(Value,",")
                   set Desc = "NONEMPTYCROSSJOIN(%OR({"_Mdx_"["
                   for j= 1:1:$ll(areaList) {
                       set area = $list(areaList,j)
                       if (j'= $ll(areaList)) {                                    
                          set Desc = Desc_area_"],"_Mdx_"["
                       } else {
                          set Desc = Desc_area_"]})"
                       }
                    }
      
             }else{ //可以查对应院区的数据
                   i data=$p(Query,"@",len){
	                   set Desc=Mdx_"["_Value_"]"
	               }else{
		               set Desc = "NONEMPTYCROSSJOIN("_Mdx_"["_Value_"]"
		           }
                                   
             }
             
             i FilterPara="" S FilterPara=Desc
             e   s FilterPara=FilterPara_","_Desc
             w !,i
     
      }
      w !,"d"_FilterPara
       s mdxString="SELECT NON EMPTY [HosDr].[H1].[HosDr].Members ON 0,NON EMPTY [QueryDate].[H1].[QueryMonth].Members ON 1 FROM [CUBE.PACKAGESALE] %FILTER"
                 _" "_FilterPara_last
                 
       w !,"mdxString="_mdxString
       
       if mdxString [ "MEASURES" {

            
	       }
]]></Implementation>
</Method>
</Class>


<Package name="Query" sqlname="Query"/>
</Export>
